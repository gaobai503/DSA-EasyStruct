# 支持多数据类型的常用数据结构

## 包括的数据结构:

* 线性表(链表)
* 栈
* 队列
* 树

## 使用方法

首先, 你需要按照一种约定准备你要传递的结构, 具体准备的方式有两种: 

### 仅存储地址, 不备份内容

如果你的结构中包含地址, 而你在存储时仅仅需要保存下来这个地址, 你可以直接不做处理的传递. 

但是, 如果你采取了这种存储法, 这意味着: 
1. 你存储的仅仅是地址, 如果在该位置的值发生变化, 你需要自己对其负责, 我不会对其做任何操作
2. 我不会申请除了地址以外的空间, 当然我也不会释放它们, 所以你仍需要在`Delete`节点后, 自行决定是否释放该地址的内存. 
3. 存储范围极广, 所有的指针都能用这种方式存储. 

### 存储备份的内容, 而非地址

如果你需要的不是存储原结构的地址, 而是做一个备份, 那么你需要按照约定规划你的结构. 
1. 你的需要备份的内容应当每次仅由一个首地址给出, 指向地址的指针不被接受, 且不会被检查, 这可能导致错误. 
2. 将你的需要以此方法传递的指针放在结构体的最前面. 
3. 所有的非指针变量都以备份的方式传递, 无需处理. 

### 准备数据类型信息结构体

首先, 你需要填充一个特殊的结构体: 
```c
struct DATATYPE{
    size_t size;
    unsigned pointer_count;
    size_t *pointer_size;
};
typedef struct DATATYPE datatype
```

在这里, 你要填充的内容包括:
1. `size`类型的字节数, 如`sizeof(struct DATATYPE)`
2. `pointer_count`类型中需要传递内容的指针数, 这个数应当不大于你的结构中包含的指针数;
3. `pointer_size`从第一个开始, 每个指针指向区域的空间大小. 

### 数据类型函数的使用

如你在`Link.h`和`Tree.h`中所见, 将`datatype`型内容放在MakeNull\[struct\]\(datatype\)中,
在传递结构类型中传递结构的地址即可. 
